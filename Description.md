# OVERVIEW
This program is a simple implementation of the producer-consumer problem using a buffer table in C. That is, a producer process (the code for which is in producer.c) creates items until a buffer table is full, and a consumer process (the code for which is in consumer.c) consumes items until said table is empty, and these processes are ran concurrently. It uses the shared memory and semaphore functionality defined in the C Standard & POSIX library to achieve this.

# SHARED MEMORY, SEMAPHORE & THREAD SETUP
The implementation is accomplished by creating and storing a table in a shared memory object using the shm_open function from the <sys/mman.h> header of the POSIX library. The table is an instance of an explicitly defined struct table_t, containing an array of size TABLE_SIZE (this is an editable parameter defined near the beginning of each code file, set to 2 by default) of items, and an integer to count the number of items currently in the table. The program also defines semaphores from the <semaphore.h> header for the number of slots full, number of slots empty, and to manage mutual exclusion between threads. Both processes (the code for which is in producer.c and consumer.c) will either create these shared memory resources, or open them if already created, in their respective main() functions. Then, from the <pthread.h> header, threads are concurrently ran for the producer and consumer.

# LOOP DESCRIPTION
The thread functions are defined to end their loop after MAX_RUNTIME seconds (this is an editable parameter, set to 5 by default). The loops are time-bounded by default (INFINITE_LOOP is set to 0 by default), but can be set to be infinite loops (by setting the editable parameter INFINITE_LOOP to 1 instead).

# PRODUCER THREAD
The producer thread will wait until both the mutual exclusion semaphore indicates its turn, and the semaphore tracking empty slots shows that the table is not full, before running its critical section. Its critical section adds an item (an integer representing the total number of items produced thus far) to the table, and increments the table position (count) and item number before signaling via the semaphores that its critical section is over. A line giving information about its production is also printed during its critical section. At the end of the loop, a delay of DELAY seconds (this is an editable parameter, set to 1 by default. Note it may also be set to 0.) is added to make output more easily readable.

# CONSUMER THREAD
The consumer thread will wait until both the mutual exclusion semaphore indicates its turn, and the semaphore tracking full slots shows that the table is not empty, before running its critical section. Its critical section consumes an item from the table by setting its item variable to the value of the current table position, and decrements the table position (count) to indicate that item has been consumed before signaling via the semaphores that its critical section is over. A line giving information about its consumption is also printed during its critical section. At the end of the loop, a delay of DELAY seconds is added to make output more easily readable.

# CLEANUP
Cleanup functions for both files are also defined to unlink and close the shared resources, and these functions are ran at the beginning and end of execution, or if any setup operation in the main() functions fail. If this is not done, the program may reuse data from shared memory from previous instances of running the program, which is unwanted behavior.
